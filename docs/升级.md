# 升级Loki

尽一切努力保持 Loki 向后兼容，这样升级应该是低风险和低分歧的。

不幸的是，Loki 是软件，软件很难，有时我们不得不在易用性和易维护性之间做出决定。

如果我们有任何升级困难的预期，我们将在此处记录。

随着更多版本的发布，一次在多个版本之间移动时出现意外问题的可能性更大。如果可能，请尝试保持最新状态并按照顺序进行更新。如果您想跳过某个版本，请在在升级生产环境之前在开发环境中测试。

## Master / Unreleased

-*在此处添加未发布的更改*

## 2.2.0

### Loki

**在升级到 2.2 之前，请务必升级到 2.0 或 2.1**

在 Loki 2.2 中，我们将块格式的内部版本从 v2 更改为 v3，这是一个透明的更改，并且仅当您尝试降级Loki 安装时才有意义。我们在 2.0.1 和 2.1 以及 2.2 和任何未来版本中合并了读取 v3 块的代码。

**如果升级到 2.2+，创建的任何块只能由 2.0.1、2.1 和 2.2+ 读取**

这使得在升级到 2.2之前首先升级到 2.0、2.0.1 或 2.1 很重要，这样如果您出于任何原因需要回滚，您可以轻松地做到这一点。

**注意：** 2.0 和 2.0.1 在各个方面都相同，除了 2.0.1 包含读取 v3 块格式所需的代码。所以如果你是2.0升级到2.2，如果要回滚，必须回滚到2.0.1。

### Loki配置

**如果您使用查询前端并具有 `sharded_queries_enabled: true`请阅读此处**

我们发现在长时间范围内与分片查询相关的查询调度可能会导致每个租户工作队列中的单个查询出现不公平的工作调度。

该`max_query_parallelism`设置旨在限制允许一次将单个查询的“工作”的拆分和分片单元的数量放入每个租户的工作队列中。之前的行为会使用 将查询按时间拆分`split_queries_by_interval`，并将此值与`max_query_parallelism`填充队列时进行比较，但是在启用分片的情况下，`max_query_parallelism`在应用限制后，每个拆分都会被分片为 16 个额外的工作单元。

在 2.2 中，我们更改了此行为以应用对查询`max_query_parallelism`进行拆分*和*分片后*，*从而为每个查询进行更公平和预期的队列调度。

**这意味着**如果您使用查询前端并启用了 sharding_queries_enabled（您应该这样做），Loki 将在每个查询的工作队列中投入更少的工作。 **如果您发现查询性能变慢，则****可能需要增加`max_query_parallelism`设置**实际上，除非您运行具有大量查询器的集群或具有非常高的`parallelism`frontend_worker 设置的查询器，否则您可能看不到差异。

您可以考虑将当前`max_query_parallelism`设置乘以16 以获得先前的行为，但实际上我们怀疑很少有人会真正想要这么高，除非您有一个重要的查询器工作池。

**还要注意确保`max_outsdanting_per_tenant`始终大于`max_query_parallelism`或大型查询将自动失败并向用户返回 429。**

### Promtail

对于 2.0，我们消除了`entry_parser`Promtail 配置中长期弃用的配置，但是这样做时我们引入了一个非常混乱和错误的默认行为：

如果您没有指定`pipeline_stages`条目，您将获得一个包含`docker`管道阶段的默认值。这可能会导致一些非常令人困惑的结果。

在[3404 中](https://github.com/grafana/loki/pull/3404)，我们更正了此行为

**如果您正在使用 docker，并且您`scrape_configs`缺少任何`pipeline_stages`定义**，则应添加以下内容以获得正确的行为：

```yaml
pipeline_stages:
  - docker: {}
```

YAML

## 2.1.0

从 2.0.0 升级到 2.1.0 应该还算顺利，请注意以下两点：